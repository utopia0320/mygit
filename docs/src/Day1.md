---
src/Day1.md            -->  /Day1.html (accessible as /)
src/Day2.md            -->  /Day2.html
---
# 객체지향(OOP)  
   -객체지향이란? 인간의 현실세계를 정보화 시스템으로 반영하기 위해 모든 개졈등을 객체화 시켜 프로그램에 반영 하는 것
   -객체란 ? 유,무형의 물체/현상/사건 등을 의미..
   -객체의 특징 : 객체는 속성과 행위를 갖는다. 속성은 변수로, 행위는 함수로 구성한다. 이를 객체 모델링이라 한다.
 겍체지향 프로그래밍에서는 변수를 맴버변수(속성)로 함수를 메소드라 부른다.
   
   -객체지향 프로그래밍의 순서
    1.프로그램에 필요한 객체를 뽑아낸다.
    2.객체 모델링
    3.클래스 구성
    4.객체 생성 및 사용 
   
   -객체지향 언어의 특징
1. 캡슐화(Encapsulation =은닉화)  : 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것.  예)getter/setter
2. 상속성(extends) : 추상화 한 클래스(부모)에 새로운 기능이나 속성을 추가하여 새로운 클래스(자식)로 만드는 것을 의미(개발시간 단축, 재사용성..)
3. 다형성 : 오버로딩(중복정의)/오버라이딩(재정의)  + 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것
4. 추상화(Abstraction) : 어떤 물체에서 주된 특징을 부각시켜 표현하고, 나머지 부분은 과감하게 생략하는 것, oop에서 사용되는 추상화도 이와 비슷하다. (한 물체를 대표하는)객체의 
공통적인 속성(명사)와 행위(동사)를 추출하여 정의하는 것을 프로그래밍에서는 추상화라고 한다.


2. SOLID (객체지향설계)
-S(SRP) 단일 책임의 원칙 : 작성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중 되어 있어야 한다.
-O(OCP) 개방폐쇄의 원칙 : 소프트웨어의 구성요소(컴포넌트,클래스,모듈,함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다.기존 구성요소는 수정이 일어나지 말아야 하며, 쉽게 확장 해 재사용 할 수 있어야 한다.
-L(LSP) 리스코브 치환의 법칙 : 서브타입은 언제든 기반 타입으로 교체할 수 있어야 한다. 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 함(올바른 상속관계의 특징 정의, 쉽게 말해서 자식 클래스가 부모 클래스 대신 사용될 수 있어야 한다는 말!)
-I(ISP) 인터페이스 분리의 법칙 : 사용하지 않는 인터페이스는 구현하지 말아야 한다. 즉 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공해야 한다.  인터페이스의 분리/단일책임
-D(DIP) 의존성역전의 원칙 :  의존 관계를 맺을 때, 변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 함

3.스프링의 3요소(pojo 순수java만을 사용하여 만든 객체)
- LoC(제어의 역전)/ DI(의존성 주입)  : 스프링이 사용할 객체를 생성하여 의존 관계를 맺어주는 것을 IoC, 그 과정에서 생성자를 통해 주입해주는 것을 DI
- AOP(관점 지향 프로그래밍) : 공통적으로 나타나는 부가적인 기능들을 독립적으로 모듈화하는 프로그래밍 모델 
- PSA(서비스 추상화) : 특정 환경이나 서버, 기술에 종속되지 않으며 유연한 개발을 할 수 있게 한다.  특정 기술과 관련된 서비스를 추상화하여 일관된 방식으로 사용될 수 있도록 한 것 (JDBC)




[1 클래스의 정의]
클래스란: 인간 세계의 객체를 추상화 한 것. 즉, 객체의 설계도라 할 수 있다
클래스도 하나의 자료구조다. 즉 데이타 타입이다
선언)
*클래스의 멤버로는 멤버변수와 메서드등을 갖는다
접근지정자 [modifier] class 클래스명{  //클래스명은 대문자로 시작

접근지정자 자료형 멤버변수명;
접근지정자 반환형 메서드

}

[2 객체 생성 및 멤버접근방법]
클래스명 인스턴스변수 = new 생성자();

*클래스 멤버 접근 방법
인스턴스형 맴버(instance)에는 인스턴스변수.멤버로 접근
정적멤버(static)에는 클래스명.멤버로 접근

 -멤버변수는 크게 정적멤버 변수와 인스턴스형 멤버변수로 나눈다
 -멤버메소드도 정적메소드와 인스턴스형 메소드로 나눈다.
 -멤버변수나 멤버 메소드 앞에 static이라는 modifier가 붙으면 정적 멤버 즉, 정적 멤버변수이거나 정적 메소드이다.
  
   예] int age;  //인스턴스형 멤버변수
      static int age;  //정적 멤버변수
       
       public void method(){};     //인스턴스형 메소드
       public static void method(){};    //정적 메소드
       
단,class앞에는 static을 붙일 수 없다
 
 ※ 정적멤버(변수 혹은 메소드)의 메모리는 JVM에서 클래스를 로드할 시점에 생기고,
     인스턴스형 멤버는 JVM에서 인터프리터 할 때 메모리가 생성된다.
     
 ※ 클래스의 멤버에 접근시 접근 방법  
1]인스턴스형 멤버 : 인스턴스형변수.멤버
   클래스명 인스턴스형변수 = new 생성자();
   인스턴스형변수.멤버;
2]정적 멤버 :클래스명.멤버


[3 접근 지정자(access modifier)]

접근지정자: 클래스와 클래스간에 access법위를 지정하는 기능

[접근지정자를 붙일 수 잇는곳]:
1.접근지정자 [modifier] class 클래스명
2.접근지정자 final 자료형 멤버상수=초기값  : 접근지정자와 modifier는 순서는 상관없다
  final 접근지정자 자료형 멤버상수=초기값
3.접근지정자 [modifier] 자료형 멤버변수;
4.접근지정자 [modifier] 반환타입 메소드명;
  단, class 앞에 붙일 수 있는 접근지정자는 public과 생략형만 붙일 수 있다.

접근지정자 범위 : private < 생략형 < protected < public

private : 자기 클래스내에서만 접근 가능
생략형(디폴트접근 지정자,패키지접근지정자) : 같은 패키지 안에서만 접근 가능
protected : 같은 패키지는 물론 다른 패키지일지라도 상속관계가 있으면 접근 가능
public : 어디서나 접근 가능


[은닉화(Encapsulation)]
- 멤버변수를 캡슐화하되 멤버변수에 접근할 때는 메소드로 접근하도록 한다.
- 캡슐화 방법
1. 멤버 변수 앞에 private 접근 지정자를 붙인다.
   예] private int balance;
2. 멤버 변수에 값을 할당하고 값을 꺼내올 수 있는 
   메소드를 만든다.
   2.1 setter메소드.
    메소드의 접근 지정자는 public 반환타입은 없고, 매개변수를 받아들이도록 한다
    setter메소드의 역할 : 매개변수의 값을 멤버변수에 할당하는 일.
public void setBalnace(int money){
balance=money;
}
   2.2 getter메소드
        메소드들은 반환타입이 있되 매개변수는 받아들이지 않는다.
    getter메소드의 역할: 멤버변수 설정된 값을 반환해주는 일
public int getBalance(){
return balnace;
}
[this와 super]
  1] this 키워드
        -자기 자신의 인스턴스형 멤버에 접근할때 사용하는 키워드         
-정적 메소드 안에서 사용할 수 없다.
  예]
private int balance;   //멤버변수
public void setBalnace(int balance){    //매개변수(지역변수)
//balance=balance;        //매개변수=매개변수 
this.balabce=balance;     //멤버변수 = 지역변수
}

  2] super 키워드
    - 부모클래스의 멤버에 접근할때 사용(단,private는 접근 불가)    
    - 정적 메소드 안에서 사용할 수 없다.

[다형성(Polymorphism)]
*메소드와 관련된 개념
1] 오버로딩(Overloading) - 중복 정의
    하나의 클래스 안에서 적용되는 개념으로 같은 이름의 메서드를 여러 개 정의 할 수 있다
    - 메소드명이 동일해야 한다.
    - 매개변수의 데이터 타입이 다름
    - 매개변수의 개수가 다름
    - 매개변수의 타입이 다름, (순서가 달라도 해당)
    - 메소드의 반환타입은 상관이 없다.(해당x)

2] 오버라이딩(Overriding)-재 정의
    상속 시에 적용되는개념 즉 부모로부터 상속 받은 메소드를 재 정의해서 사용하는 것
    - 메소드명이 동일해야 한다.
    - 메소드의 매개변수 개수,데이터타입이 같아야 한다.
    - 메소드의 반환타입도 같아야 한다.
    - 부모 메서드의 접근 지정자가 
       public이거나 protected인 경우에만 오버라이딩이 된다.
    - 부모 메서드가 default 지정자나 private지정자를 가진 메서드를 오버라이딩 한 경우
       자식 고유의 메서드로 처리된다(오버라이딩 한 것이 아님)
       단,default접근 지정자는 다른 패키지에서는 접근이 안됨으로 부모와 자식이 다른 패키지일 경우에만 오버라이딩 한것이 아님.
       같은 패키지일 경우는 오버라이딩에 해당
    - Exception의 경우 부모 클래스의 메소드와 동일하거나 더 구체적인 Exception을 발생시켜야 한다.

[생성자]
1]생성자란?
   :객체가 생성될 때(인스턴스화)최초로 실행되는 메소드를 의미.  
2]생성자 특징
- 생성자 이름은 클래스명과 동일해야 한다
- 반환타입을 가져선 안된다.
- 생성자의 접근지정자로는 주로 public속성
3]생성자의 역할
- 멤버 변수를 초기화 하는 일
- 생성자를 구현하지 않았을 경우 컴파일러는 default생성자를 제공해줌
        - 생성자를 하나라도 구현했다면, 그 때는 컴파일러가 default생성자를 제공 해주지 않는다.
- 생성자를 다양하게 오버로딩 함으로써 다양한 초기값을 부여할 수 있다.

[this() 와 super()]
1] this()
- 생성자 안에서 자기 자신의 생성자를 호출하는 메소드
- 한 클래스 안에 여러 개의 생성자가 오버로딩된 형태로 존재하고,그 기능이 유사할 때
  this()라는 키워드를 이용해서 자기 자신의 다른 생성자를 호출할 수 있다.
- 단, this()는 생성자 안에서만 호출해야 한다.
- this()를 호출할 때는 반드시 생성자의 첫번째 문장이어야 한다.
        - 생성자 안에서 this()와 super()를 함께 쓸 수 없다.
2] super()
- 자식 클래스를 인스턴스화 할때 컴파일러가 기본적으로 자식의 생성자안에서 자동으로  
  부모의 기본 생성자인 super()를 호출한다
- 부모의 생성자중 오버로딩 된 인자 생성자를 명시적으로 호출할 때 사용
- super()역시 생성자 안에서만 호출
- 생성자의 맨 첫줄에 위치 해야 한다.
- 부모에 인자 생성자를 만들때는 부모에 기본생성자를 만드는게 유리하다. 왜냐하면 자식 클래스의 객체 생성시(인스턴스화)
  자식 클래스의 생성자에서 기본적으로 부모의 기본 생성자(super())를 호출하기 때문에
  부모에 기본 생성자가 없는 경우 에러남

소스예]
class Parent
{

String name;
//기본 생성자가 없음으로 컴파일러가 자동으로 기본 생성자를 생성해 주지 않음
public Parent(String name){
this.name=name;
}

}
class Child extends Parent
{
public Child(){
 //아래 문장 생략시 부모의 기본 생성자인 super()호출 함으로 에러
 super("홍길동");
}
}

[상속성(Inheritance)]
- 추상화한 클래스(부모)에 새로운 기능이나 속성을 추가하여 새로운 클래스(자식)로 만드는 것을 의미.
- 상속 개념을 적용함으로써 개발시간 단축, 재사용성 등으로 OOP 장점을 살릴 수 있다.
- 상속 관계는 부모와 자식간에 "자식 is a 부모"라는 is a 관계가 성립할 때 맺을 수 있다
- 자바에서 상속을 받을 때는 extends란 키워드를 사용.
- 자바는 단일 상속 개념이므로 extends 로 상속 받을 수 있는 클래스는 단 하나뿐이다.

  *상속과 관련된 또 하나의 개념 heterogeneous(이질화)  
<---->homogeneou(배열):같은 타입의 데이타 저장
- 부모타입 참조변수=new 자식의객체생성  <=부모와 자식의 상속관계일 때 가능
    단,자식타입 참조변수 = new 부모타입(X)
   - 부모타입으로 변수 선언을 하고 자식의 객체를 생성했을 경우 그 참조변수로 참조할 수 있는 범위는 제한이 있다.
     1. 부모로부터 물려받은 변수,메소드 - 접근가능
  2. 자식이 오버라이딩한 메소드가 있을 경우, 그 오버라이딩한 메소드를 우선 호출한다. - 접근가능
  3. 자식이 가지는 고유한 변수 메소드 - 접근 불가능
  4. 자식이 오버로딩한 메소드 - 접근 불가능
   -접근 못하는 경우 자식클래스 타입으로 형변환 하면 접근 가능하다
      ((자식타입)참조변수).접근못하는 메소드나 변수
-부모타입의 배열 선언 후 자식객체 및 부모 객체 모두 저장 가능 
     단, 이때도 자식 객체를 할당 하더라도 부모타입의 배열에 자식 객체를 할당 하기때문에
 참조 범위는 위의 내용과 같다. 고로 배열이지만 heterogeneou컬렉션이 됨.